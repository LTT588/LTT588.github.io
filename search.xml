<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>blog1</title>
    <url>/2022/09/13/blog1/</url>
    <content><![CDATA[<h2 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h2><p>接口：interface</p>
<p>抽象类：abstract </p>
<p>都不能被实例化，即不能使用new关键字来实例化对象  只能被继承</p>
<p>抽象类是一个抽象的概念  接口是共同的特征   比如说男人、女人是两个类 那么他们的抽象类是人 （他们都是人）  比如鸟和飞机 会飞  设计一个接口fly  </p>
<p>Java抽象类只能继承一个类（单继承）  但可以实现多个接口</p>
<p>抽象类可定义构造方法 可以有抽象方法和具体方法  接口没有构造方法且方法都是抽象的</p>
<h2 id="查看linux内存使用情况"><a href="#查看linux内存使用情况" class="headerlink" title="查看linux内存使用情况"></a>查看linux内存使用情况</h2><ol>
<li>cat &#x2F;proc&#x2F;meminfo</li>
<li>atop</li>
<li>free</li>
<li>top</li>
</ol>
<h2 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h2><p><strong>乐观锁的实现方式</strong>：比较典型的一种是  CAS技术   </p>
<p>但是会有ABA问题</p>
<p>比如说一个线程1从数据库中取出库存数3，这时候另一个线程2也从数据库中库存数3，并且线程2进行了一些操作将库存数变成了2，紧接着又将库存数变成3，这时候线程1进行CAS操作发现数据库中仍然是3，然后线程1操作成功。尽管线程1的CAS操作成功，但是不代表这个过程就是没有问题的。</p>
<p>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。</p>
<p><strong>悲观锁的实现方式</strong>：</p>
<ul>
<li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>其间如果有其他事务对该记录做加锁的操作，都要等待当前事务解锁或直接抛出异常。</li>
</ul>
<h2 id="数据库的四大特性"><a href="#数据库的四大特性" class="headerlink" title="数据库的四大特性"></a>数据库的四大特性</h2><p>​															<strong>原子性 一致性 隔离性 持久性</strong></p>
<p><strong>原子性</strong>：一个事物要么都成功，要么都失败，不会存在部分成功部分失败</p>
<p><strong>一致性</strong>：一个事物执行前后状态保持一致</p>
<p><strong>隔离性</strong>：两个事务之间互不干扰</p>
<p><strong>持久性</strong>：一个事物一单提交，永久保存</p>
<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><ol>
<li><strong>读未提交度</strong>           最危险，什么情况都有可能发生：脏读、不可重复读、幻读</li>
<li><strong>读已提交度</strong>            防止脏读、但可能出现 不可重复读、幻读</li>
<li><strong>可重复读</strong>             数据库默认隔离级别。但有可能出现幻读</li>
<li><strong>可串行化</strong>            级别最高  相当于单线程，全表锁，一次只能执行一个事物，执行效率最差</li>
</ol>
<p><strong>脏读</strong>：当一个事物正在访问数据并且对数据进行了修改，而这种数据修改还没有提交到数据库中，这时另外一个事物也访问了这个数据，然后使用了这个数据， 因为这个数据还没有提交到数据库，那么另外一个事物读到的数据是脏数据</p>
<p><strong>不可重复读</strong>：在一个事务内多次读同一数据，在这个事物还没有结束时，另一个事务也访问该数据，那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不一样    </p>
<p><strong>幻读</strong>：幻读与不可重复读类似，他发生在一个事物读取了几行数据，接着另一个并发事务插入了一些数据，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录   就好像发生了幻觉一样 所以称为幻读</p>
<p>​					<strong>不可重复读与幻读的区别</strong>：不可重复读的重点是修改    比如多次读取一条数据发现其中某些列的值被修改，幻读的重点在于新增或者删除  比如多次读取一条记录发现记录增多或减少了</p>
<h2 id="如何查看数据库隔离级别、如何修改"><a href="#如何查看数据库隔离级别、如何修改" class="headerlink" title="如何查看数据库隔离级别、如何修改"></a>如何查看数据库隔离级别、如何修改</h2><ol>
<li><p>如何查看数据库隔离级别</p>
<p>show variables like “%isolation%”;或   select @@tx_isolation;</p>
</li>
<li><p>修改隔离级别</p>
<p>​        全局修改：set global transaction isolation level read committed;</p>
<p>本次事务修改：set session transaction isolation level read committed;</p>
</li>
</ol>
<h2 id="MySQL存储引擎之MyISAM和InnoDB"><a href="#MySQL存储引擎之MyISAM和InnoDB" class="headerlink" title="MySQL存储引擎之MyISAM和InnoDB"></a>MySQL存储引擎之MyISAM和InnoDB</h2>]]></content>
      <categories>
        <category>categories</category>
        <category>notes</category>
      </categories>
  </entry>
  <entry>
    <title>helloworld</title>
    <url>/2022/09/13/helloworld/</url>
    <content><![CDATA[<p> 博客搭建中……</p>
]]></content>
  </entry>
</search>
